---
outline: deep
---

# 线性数据结构（栈、队列和链表）

## 栈和队列

在 JavaScript 中，**栈和队列的实现一般都要依赖于数组**，可以当做“特别的数组”。

（注：实际上，栈和队列作为两种运算受限的**线性表**。）

区别：它们各自对数组的**增删操作**有着不一样的限制

### 灵活增删的数组

数组的增删操作可以说是没有任何限制的，允许在任何位置执行想要的操作。

#### 数组中增加元素的三种方法

- unshift 方法-添加元素到数组的头部

```ts
const arr = [1, 2];
arr.unshift(0); // [0,1,2]
```

- push 方法-添加元素到数组的尾部

```ts
const arr = [1, 2];
arr.push(3); // [1,2,3]
```

- splice 方法-添加元素到数组的任何位置

```ts
const arr = [1, 2];
arr.splice(1, 0, 3); // [1,3,2]
```

删除数组任意位置的元素

```ts
const arr = [1, 2];
arr.splice(1, 1); // [1]
```

splice 方法：

```ts
array.splice(start, deleteCount, item1, item2, ...);
```

第一个入参是起始的索引值，第二个入参表示从起始索引开始需要删除的元素个数。这里我们指明从索引为 1 的元素开始，删掉 1 个元素，也就相当于把 arr[1] 给删掉了。这就是数组中**删除任意位置元素的方法**。

至于传入两个以上参数这种用法，是用于在删除的同时完成数组元素的新增。而从第三个位置开始的入参，都代表着需要添加到数组里的元素的值：

```ts
arr.splice(1, 0, 3); // [1,3,2]
```

在这个例子里，指明了从 arr[1] 开始，删掉 0 个元素，并且在索引为 1 的地方新增了值为 3 的元素。
因为删掉的元素是 0 个，所以说 arr[1] 中原有的元素值“2”仍然会被保留下来；同时因为后面又指定了 arr[1] 处需要新增一个元素 3，那么这个 3 就会把原来 arr[1]这个地方的元素给“挤到后面去”。这样就做到了在数组中任意位置进行元素的新增。这个过程如下图：

![An image](/array/add.png)

#### 数组中删除元素的三种方法

- shift 方法-删除数组头部的元素

```ts
const arr = [1, 2, 3];
arr.shift(); // [2,3]
```

- pop 方法-删除数组尾部的元素

```ts
const arr = [1, 2, 3];
arr.pop(); // [1,2]
```

- splice 方法-删除数组任意位置的元素

splice 方法上文已经详细讲过，此处不再赘述。

### 栈（Stack）——只用 pop 和 push 完成增删的“数组”

栈是一种**后进先出**(LIFO，Last In First Out)的数据结构。

![An image](/stack/stack-in.png)
![An image](/stack/stack-out.png)

这个过程有两个特征：

- 只允许从尾部添加元素
- 只允许从尾部取出元素
  对应到数组的方法，刚好就是 push 和 pop。因此，可以认为在 JavaScript 中，**栈就是限制只能用 push 来添加元素，同时只能用 pop 来移除元素的一种特殊的数组**

基于数组来实现一波栈的常用操作，完成“放置冰淇淋”和“卖冰淇淋”的过程：

```ts
// 初始状态，栈空
const stack = [];
// 入栈过程
stack.push('东北大板');
stack.push('可爱多');
stack.push('巧乐兹');
stack.push('冰工厂');
stack.push('光明奶砖');

// 出栈过程，栈不为空时才执行
while (stack.length) {
	// 单纯访问栈顶元素（不出栈）
	const top = stack[stack.length - 1];
	console.log('现在取出的冰淇淋是', top);
	// 将栈顶元素出栈
	stack.pop();
}

// 栈空
stack; // []
```

### 队列（Queue）——只用 push 和 shift 完成增删的“数组”

队列是一种**先进先出**（FIFO，First In First Out）的数据结构。

![An image](/queue/queue-in.png)
![An image](/queue/queue-out.png)

过程的规律：

- 只允许从尾部添加元素
- 只允许从头部移除元素

整个过程只涉及了数组的 push 和 shift 方法。
在栈元素出栈时，关心的是栈顶元素（数组的最后一个元素）；队列元素出队时，关心的则是队头元素（数组的第一个元素）。

基于数组来实现一波队列的常用操作，完成“小册姐排队”和“小册姐取餐”的过程：

```ts
const queue = [];
queue.push('小册一姐');
queue.push('小册二姐');
queue.push('小册三姐');

while (queue.length) {
	// 单纯访问队头元素（不出队）
	const top = queue[0];
	console.log(top, '取餐');
	// 将队头元素出队
	queue.shift();
}

// 队空
queue; // []
```

## 链表

链表和数组相似，它们都是有序的列表、都是线性结构（有且仅有一个前驱、有且仅有一个后继）。不同点在于，链表中，数据单位的名称叫做“结点”，而结点和结点的分布，在内存中可以是**离散**的。

这个“离散”是相对于数组的“连续”来说的：

![An image](/array/1D.png)

数组在内存中最为关键的一个特征，就是它**一般**是对应一段位于自己上界和下界之间的、一段**连续**的内存空间。元素与元素之间，紧紧相连。（还有其它的特殊情况）

而链表中的结点，则允许散落在内存空间的各个角落里。一个内容为 1->2->3->4->5 的链表，在内存中的形态可以是散乱如下的：

![An image](/link/base.png)

正是由于数组中的元素是连续的，每个元素的内存地址可以根据其索引距离数组头部的距离来计算出来。因此对数组来说，每一个元素都可以通过数组的索引下标直接定位。

但是对链表来说，元素和元素之间似乎毫无内存上的瓜葛可言。就比如说咱们图上这种情况，1、2、3、4、5 各据山头，站在元素 1 的坑位里，我们对元素 2、3、4、5 的内存地址一无所知，连遍历都没法遍历。如何解决？

在链表中，每一个结点的结构都包括了两部分的内容：数据域和指针域。JS 中的链表，是以嵌套的对象的形式来实现的：

```ts
{
    // 数据域
    val: 1,
    // 指针域，指向下一个结点
    next: {
        val:2,
        next: ...
    }
}
```

数据域存储的是当前结点所存储的数据值，而指针域则代表下一个结点（后继结点）的引用。 有了 next 指针来记录后继结点的引用，每一个结点至少都能知道自己后面的同学是哪位了，原本相互独立的结点之间就有了如下的联系：

![An image](/link/simple.png)

要想访问链表中的任何一个元素，都得从起点结点开始，逐个访问 next，一直访问到目标结点为止。为了确保起点结点是可抵达的，我们有时还会设定一个 head 指针来专门指向链表的开始位置：

![An image](/link/finish.png)

### 链表结点的创建

创建链表结点，需要一个构造函数：

```ts
function ListNode(val) {
	this.val = val;
	this.next = null;
}
```

在使用构造函数创建结点时，传入 val （数据域对应的值内容）、指定 next （下一个链表结点）即可：

```ts
const node = new ListNode(1);
node.next = new ListNode(2);
```

以上，就创建出了一个数据域值为 1，next 结点数据域值为 2 的链表结点：

![An image](/link/link-1.png)

### 链表元素的添加

链表的结点间关系是通过 next 指针来维系的。因此，链表元素的添加和删除操作，本质上都是在围绕 next 指针做文章。

在尾部添加结点：

```ts
const node1 = new ListNode(1);
const node2 = new ListNode(2);
const node3 = new ListNode(3);
node1.next = node2;
node2.next = node3; // node3 添加到 node2 所在链表的尾部，直接把 node2 的 next 指针指向 node3
```

![An image](/link/link-2.png)
